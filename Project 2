#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <stdlib.h>
#include <stdio.h>
#include <Eigen/Dense>
#include <vector>
#include <MathGeoLib.h>
#include <cmath>


using namespace std;
using namespace Eigen;


#define N 10002
#define M 20000
#define f 1 //change to 175 for all frames 


void StoreNeighbourVerts(Matrix<int, Dynamic, Dynamic> Tr, Matrix<float, Dynamic, Dynamic> D, int P_index, std::vector<int> &NeighbourVerts, std::vector<int> &NeighbourRingIndex, std::vector<int> &ActiveNeighbourVerts, std::vector<int> ActiveVerts, int CurrentFrame, int flag);
void DeleteDoubles(std::vector<int> &NeighbourVerts, std::vector<int> &NeighbourRingIndex);
void IgnoreInactives(std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> ActiveVerts);
float Ca(std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> NeighbourRingIndex, int maxRing);
float Cb(std::vector<float> oldCa, std::vector<float> newCa, int ActiveSize, std::vector<int> &ActiveNeighbourVerts);
void quickSort(std::vector<float> &arr, std::vector<int> &indices, int left, int right);
void decimate(std::vector<int> &ActiveVerts, int &ActiveSize, std::vector<float> &Costs, std::vector<int> &CostInds, Matrix<int, Dynamic, Dynamic> Tr, Matrix<float, Dynamic, Dynamic> D, std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> &NeighbourRingIndex, int CurrentFrame, std::vector<float> &CaArrayNew, std::vector<float> &CaArrayOld);
void SimpleStoreNeighbourVerts(Matrix<int, Dynamic, Dynamic> Tr, int P_index, std::vector<int> &NeighbourVerts, std::vector<int> StaticActiveVerts);
float square(float a);

int main(int argc, char* argv[])
{
	string line;
	Matrix<float, Dynamic, Dynamic> D;
	Matrix<float, Dynamic, Dynamic> Dreceived;
	Matrix<float, Dynamic, Dynamic> DeltaCoord;
	Matrix<int, Dynamic, Dynamic> Tr;

	std::vector<int> ActiveVerts; // 1 if active, 0 if inactive
	std::vector<int> StaticActiveVerts; // 1 if active, 0 if inactive
	std::vector<float> CaArrayOld;
	std::vector<float> CaArrayNew;
	std::vector<float> Costs;
	std::vector<int> CostInds;
	std::vector<int> NeighbourVerts;
	std::vector<int> NeighbourRingIndex;
	std::vector<int> ActiveNeighbourVerts;
	std::vector<float> sortedDelta;
	std::vector<int> DeltaInds;

	D.resize(3 * f, N);  //all verts
	Tr.resize(3 * f, M); //all triangles
	DeltaCoord.resize(3 * f, N);
	Dreceived.resize(3 * f, N);  //received verts
	int ActiveSize = N;
	int StaticActiveSize;

	float StaticError = 0;
	float DynamicError = 0;

	//Load from files
	{
		ifstream myfileX("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\VertsX.txt");
		if (myfileX)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < N; j++)
				{
					(getline(myfileX, line));
					float v;
					string s;

					v = stof(line);

					D(3 * i, j) = v;
				}
			}
			myfileX.close();
		}
		else std::cout << "fooey\n";

		ifstream myfileY("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\VertsY.txt");
		if (myfileY)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < N; j++)
				{
					(getline(myfileY, line));
					float v;
					string s;

					v = stof(line);

					D(3 * i + 1, j) = v;
				}
			}
			myfileY.close();
		}
		else std::cout << "fooey\n";

		ifstream myfileZ("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\VertsZ.txt");
		if (myfileZ)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < N; j++)
				{
					(getline(myfileZ, line));
					float v;
					string s;

					v = stof(line);

					D(3 * i + 2, j) = v;
				}
			}
			myfileZ.close();
		}
		else std::cout << "fooey\n";

		ifstream myfile1("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\Tris1.txt");
		if (myfile1)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < M; j++)
				{
					(getline(myfile1, line));
					int v;
					string s;

					v = stoi(line);

					Tr(3 * i, j) = v - 1; //in the file indexing starts from 1 instead of 0
				}
			}
			myfile1.close();
		}
		else std::cout << "fooey\n";

		ifstream myfile2("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\Tris2.txt");
		if (myfile2)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < M; j++)
				{
					(getline(myfile2, line));
					int v;
					string s;

					v = stoi(line);

					Tr(3 * i + 1, j) = v - 1; //in the file indexing starts from 1 instead of 0
				}
			}
			myfile2.close();
		}
		else std::cout << "fooey\n";

		ifstream myfile3("C:\\Users\\Δημήτρης\\Desktop\\διπλωματικη\\Tris3.txt");
		if (myfile3)
		{
			for (int i = 0; i < f; i++)
			{
				for (int j = 0; j < M; j++)
				{
					(getline(myfile3, line));
					int v;
					string s;

					v = stoi(line);

					Tr(3 * i + 2, j) = v - 1; //in the file indexing starts from 1 instead of 0
				}
			}
			myfile3.close();
		}
		else std::cout << "fooey\n";
	}

	//eventually it will happen for every frame
	int CurrentFrame = 0;


	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Static Approximation
	{
		//ENCODER PART

		for (int i = 0; i < N; i++)
		{
			StaticActiveVerts.push_back(1);
		}

		//calculate d coordinates
		for (int i = 0; i < N; i++)
		{
			SimpleStoreNeighbourVerts(Tr, i, NeighbourVerts, StaticActiveVerts);
			vec Mean(0, 0, 0);
			vec Point(D(3 * CurrentFrame, i), D(3 * CurrentFrame + 1, i), D(3 * CurrentFrame + 2, i));

			for (int j = 0; j < NeighbourVerts.size(); j++)
			{
				vec temp(D(3 * CurrentFrame, NeighbourVerts[j]), D(3 * CurrentFrame + 1, NeighbourVerts[j]), D(3 * CurrentFrame + 2, NeighbourVerts[j]));
				Mean += temp;
			}

			//write D Coordinates 
			DeltaCoord(3 * CurrentFrame + 0, i) = Point.x - (Mean.x / NeighbourVerts.size());
			DeltaCoord(3 * CurrentFrame + 1, i) = Point.y - (Mean.y / NeighbourVerts.size());
			DeltaCoord(3 * CurrentFrame + 2, i) = Point.z - (Mean.z / NeighbourVerts.size());

			sortedDelta.push_back(vec(DeltaCoord(3 * CurrentFrame + 0, i), DeltaCoord(3 * CurrentFrame + 1, i), DeltaCoord(3 * CurrentFrame + 2, i)).LengthSq());
			DeltaInds.push_back(i);
		}

		quickSort(sortedDelta, DeltaInds, 0, N - 1);

		StaticActiveVerts.clear();

		//Statically set active verts, when half the verts are active
		for (int i = 0; i < N; i++)
		{
			StaticActiveVerts.push_back(0);
		}

		StaticActiveSize = N / 2;
		for (int i = 0; i < StaticActiveSize; i++)
		{
			StaticActiveVerts[DeltaInds[i]] = 1;
		}

		//create the matrix that will be sent
		for (int i = 0; i < N; i++)
		{
			if (StaticActiveVerts[i])
			{
				Dreceived(3 * CurrentFrame + 0, i) = D(3 * CurrentFrame + 0, i);
				Dreceived(3 * CurrentFrame + 1, i) = D(3 * CurrentFrame + 1, i);
				Dreceived(3 * CurrentFrame + 2, i) = D(3 * CurrentFrame + 2, i);
			}

		}


		//DECODER PART

		//reconstruction
		for (int i = 0; i < N; i++)
		{
			if (!StaticActiveVerts[i])
			{
				SimpleStoreNeighbourVerts(Tr, i, NeighbourVerts, StaticActiveVerts);
				vec Mean(0, 0, 0);

				for (int j = 0; j < NeighbourVerts.size(); j++)
				{
					vec point(Dreceived(3 * CurrentFrame + 0, NeighbourVerts[j]), Dreceived(3 * CurrentFrame + 1, NeighbourVerts[j]), Dreceived(3 * CurrentFrame + 2, NeighbourVerts[j]));
					Mean += point;
				}
				Mean /= NeighbourVerts.size();


				Dreceived(3 * CurrentFrame + 0, i) = Mean.x;
				Dreceived(3 * CurrentFrame + 1, i) = Mean.y;
				Dreceived(3 * CurrentFrame + 2, i) = Mean.z;
			}
		}

		//calculate Error = Sum((D-Dreceived)^2)
		for (int i = 0; i < N; i++)
		{
			StaticError += square(D(3 * CurrentFrame + 0, i) - Dreceived(3 * CurrentFrame + 0, i)) +
						   square(D(3 * CurrentFrame + 1, i) - Dreceived(3 * CurrentFrame + 1, i)) +
						   square(D(3 * CurrentFrame + 2, i) - Dreceived(3 * CurrentFrame + 2, i));
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////
	//Dynamic Approximation
	{
		//create active vertex array for the first frame
		for (int i = 0; i < N; i++)
		{
			ActiveVerts.push_back(1);
			CaArrayOld.push_back(0);
			CaArrayNew.push_back(0);
			Costs.push_back(0);
			CostInds.push_back(i);
		}

		//first decimation (vert chosen randomly for decimation)
		ActiveVerts[0] = 0;
		ActiveSize--;

		for (int i = 0; i < N; i++)
		{
			if (ActiveVerts[i])
			{
				int flag = 0;
				StoreNeighbourVerts(Tr, D, i, NeighbourVerts, NeighbourRingIndex, ActiveNeighbourVerts, ActiveVerts, CurrentFrame, flag);
				int maxRing = 0;
				for (int j = 0; j < NeighbourRingIndex.size(); j++)
				{
					maxRing = (NeighbourRingIndex[j] > maxRing) ? NeighbourRingIndex[j] : maxRing;
				}
				CaArrayNew[i] = Ca(NeighbourVerts, ActiveNeighbourVerts, NeighbourRingIndex, maxRing);
				ActiveNeighbourVerts.clear();
				NeighbourVerts.clear();
				NeighbourRingIndex.clear();
			}
		}

		for (int i = 0; i < N; i++)
		{
			if (ActiveVerts[i])
			{
				Costs[i] = CaArrayNew[i] + 0.8 * Cb(CaArrayOld, CaArrayNew, ActiveSize, ActiveNeighbourVerts);
			}
		}

		quickSort(Costs, CostInds, 0, N - 1);

		//decimate until half verts have been decimated for testing purposes
		for (int i = 0; i < (int)(N / 2); i++)
		{
			decimate(ActiveVerts, ActiveSize, Costs, CostInds, Tr, D, NeighbourVerts, ActiveNeighbourVerts, NeighbourRingIndex, CurrentFrame, CaArrayNew, CaArrayOld);
		}

	}

}


//takes as input the index to a point and stores the indices to its neighbors
void StoreNeighbourVerts(Matrix<int, Dynamic, Dynamic> Tr, Matrix<float, Dynamic, Dynamic> D, int P_index, std::vector<int> &NeighbourVerts, std::vector<int> &NeighbourRingIndex, std::vector<int> &ActiveNeighbourVerts, std::vector<int> ActiveVerts, int CurrentFrame, int flag)
{
	flag++ ; //if flag doesn't work well, define it as a global variable and initialize it here, as mentioned later

	//go through all verts and add the 1-ring neighbours to a list and also add the ring distance of every neighbour to another list
	for (int i = 0; i < M; i++)
	{
		int check = 0;
		if (Tr(3 * CurrentFrame + 0, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 1, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 2, i));

			//contains the ring distance of each neighbour
			NeighbourRingIndex.push_back(flag);
			NeighbourRingIndex.push_back(flag);
		}

		if (Tr(3 * CurrentFrame + 1, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 0, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 2, i));

			//contains the ring distance of each neighbour
			NeighbourRingIndex.push_back(flag);
			NeighbourRingIndex.push_back(flag);
		}

		if (Tr(3 * CurrentFrame + 2, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 0, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 1, i));

			//contains the ring distance of each neighbour
			NeighbourRingIndex.push_back(flag);
			NeighbourRingIndex.push_back(flag);
		}
	}

	DeleteDoubles(NeighbourVerts, NeighbourRingIndex);
	IgnoreInactives(NeighbourVerts, ActiveNeighbourVerts, ActiveVerts);

	for (int ring_count = 0; ring_count < 3; ring_count++)	//go up to 3-ring neighbours
	{
		if (ActiveNeighbourVerts.size() < 3)
		{
			flag++;
			for (int i = 0; i < NeighbourVerts.size(); i++)
			{
				StoreNeighbourVerts(Tr, D, NeighbourVerts[i], NeighbourVerts, NeighbourRingIndex, ActiveNeighbourVerts, ActiveVerts, CurrentFrame, flag);
			}

			DeleteDoubles(NeighbourVerts, NeighbourRingIndex);
			IgnoreInactives(NeighbourVerts, ActiveNeighbourVerts, ActiveVerts);

			//not sure if the static flag command will make the flag never be reinitialized again and we will end up with the flag going over 3. If so make flag global
		}
	}
	
	//delete P from Neighbours

	for (int i = 0; i < ActiveNeighbourVerts.size(); i++)
	{
		if (ActiveNeighbourVerts[i] == P_index)
		{
			ActiveNeighbourVerts.erase(ActiveNeighbourVerts.begin() + i);
		}

		if (i >= ActiveNeighbourVerts.size())
			break;
	}
}

//takes as input the index to a point and stores the indices to its neighbors
void SimpleStoreNeighbourVerts(Matrix<int, Dynamic, Dynamic> Tr, int P_index, std::vector<int> &NeighbourVerts, std::vector<int> StaticActiveVerts)
{
	int CurrentFrame = 0;
	NeighbourVerts.clear();

	for (int i = 0; i < M; i++)
	{
		if (Tr(3 * CurrentFrame + 0, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 1, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 2, i));
		}

		if (Tr(3 * CurrentFrame + 1, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 0, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 2, i));
		}

		if (Tr(3 * CurrentFrame + 2, i) == P_index)
		{
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 0, i));
			NeighbourVerts.push_back(Tr(3 * CurrentFrame + 1, i));
		}
	}


	//delete inactives
	for (int i = 0; i < NeighbourVerts.size(); i++)
	{
		if(!StaticActiveVerts[NeighbourVerts[i]])
			NeighbourVerts.erase(NeighbourVerts.begin() + i--);//decreases i counter in case two sequential verts are inactive
	}

	//deletes doubles
	for (int i = 0; i < NeighbourVerts.size(); i++)
	{
		for (int j = i; j < NeighbourVerts.size(); j++)
		{
			if (i != j && NeighbourVerts[i] == NeighbourVerts[j])
			{
				NeighbourVerts.erase(NeighbourVerts.begin() + j);

				j--;
			}
			if (i >= NeighbourVerts.size() || j >= NeighbourVerts.size()) break;
		}
		if (i >= NeighbourVerts.size()) break;
	}
}

void DeleteDoubles(std::vector<int> &NeighbourVerts, std::vector<int> &NeighbourRingIndex)
{
	for (int i = 0; i < NeighbourVerts.size(); i++)
	{
		for (int j = 0; j < NeighbourVerts.size(); j++)
		{
			if (i != j && NeighbourVerts[i] == NeighbourVerts[j])
			{
				NeighbourVerts.erase(NeighbourVerts.begin() + j);
				NeighbourRingIndex.erase(NeighbourRingIndex.begin() + j);

				j = i; //on the next iteration j = i + 1 so that it rechecks list
			}
			if (i >= NeighbourVerts.size() || j >= NeighbourVerts.size()) break;
		}
		if (i >= NeighbourVerts.size()) break;
	}
}

void IgnoreInactives(std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> ActiveVerts)
{
	//Finds and passes on Active vertices
	for (int i = 0; i < NeighbourVerts.size(); i++)
	{
		if (ActiveVerts[NeighbourVerts[i]])
			ActiveNeighbourVerts.push_back(NeighbourVerts[i]);
		else
		{
			if (i == 0  && ActiveNeighbourVerts.size())
				ActiveNeighbourVerts.push_back(-1);		//if first element is inactive make its index -1

			if (i != 0 && ActiveNeighbourVerts.size())
				ActiveNeighbourVerts.push_back(ActiveNeighbourVerts.size() - 1); //if inactive vert, duplicate the previous entry for later check at cost functions
		}
		//example: [0 3 2 2 2 4] 4rth and 5th element are inactive
	}
}

float Ca(std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> NeighbourRingIndex, int maxRing)
{
	float Cost = 0;


	for (int i = 1; i < maxRing; i++)
	{
		int Actives = 0;
		int RingNeigbours = 0;

		for (int j = 1; j < NeighbourVerts.size(); j++)
		{
			//Check for duplicate vecs in ActiveNeighbourVerts because that means inactive vert
			if (ActiveNeighbourVerts[j] != ActiveNeighbourVerts[j - 1] && NeighbourRingIndex[j] == i)
				Actives++;
			if (NeighbourRingIndex[j] == i)
				RingNeigbours++;
		}

		if(RingNeigbours)
			Cost += ((RingNeigbours - Actives) / RingNeigbours) * pow(0.6, i);
	}

	return Cost;
}

float Cb(std::vector<float> oldCa, std::vector<float> newCa, int ActiveSize, std::vector<int> &ActiveNeighbourVerts)
{
	float Cost = 0;


	for (int i = 1; i < ActiveSize; i++)
	{
		//Check for duplicate vecs in ActiveNeighbourVerts because that means inactive vert
		if (ActiveNeighbourVerts[i] != ActiveNeighbourVerts[i - 1])
		{
			Cost += (oldCa[i] - newCa[i]) / (ActiveSize + 1); 
		}
	}
	return Cost;
}

void decimate(std::vector<int> &ActiveVerts, int &ActiveSize, std::vector<float> &Costs, std::vector<int> &CostInds, Matrix<int, Dynamic, Dynamic> Tr, Matrix<float, Dynamic, Dynamic> D, std::vector<int> &NeighbourVerts, std::vector<int> &ActiveNeighbourVerts, std::vector<int> &NeighbourRingIndex, int CurrentFrame, std::vector<float> &CaArrayNew, std::vector<float> &CaArrayOld)
{
	ActiveVerts[CostInds[N]] = 0; //decimate the verts with the smallest cost
	ActiveSize--;

	for (int i = 0; i < N; i++)
	{
		if (ActiveVerts[i])
		{
			int flag = 0;
			StoreNeighbourVerts(Tr, D, i, NeighbourVerts, NeighbourRingIndex, ActiveNeighbourVerts, ActiveVerts, CurrentFrame, flag);
			int maxRing = 0;
			for (int j = 0; j < NeighbourRingIndex.size(); j++)
			{
				maxRing = (NeighbourRingIndex[j] > maxRing) ? NeighbourRingIndex[j] : maxRing;
			}
			CaArrayNew[i] = Ca(NeighbourVerts, ActiveNeighbourVerts, NeighbourRingIndex, maxRing);
			ActiveNeighbourVerts.clear();
			NeighbourVerts.clear();
		}
	}

	for (int i = 0; i < N; i++)
	{
		if (ActiveVerts[i])
		{
			Costs[i] = CaArrayNew[i] + 0.8 * Cb(CaArrayOld, CaArrayNew, ActiveSize, ActiveNeighbourVerts);
		}
	}

	quickSort(Costs, CostInds, 0, N - 1);
}

void quickSort(std::vector<float> &arr, std::vector<int> &indices, int left, int right)
{
	int i = left, j = right;
	float tmp1;
	int tmp2;
	float pivot = arr[(left + right) / 2];



	/* partition */

	while (i <= j)
	{
		while (arr[i] < pivot)	i++;

		while (arr[j] > pivot)	j--;


		if (i <= j)
		{
			tmp1 = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp1;


			tmp2 = indices[i];
			indices[i] = indices[j];
			indices[j] = tmp2;

			i++;
			j--;
		}
	};



	/* recursion */

	if (left < j)
		quickSort(arr, indices, left, j);

	if (i < right)
		quickSort(arr, indices, i, right);

}

//square function
float square(float a)
{
	return a * a;
}
